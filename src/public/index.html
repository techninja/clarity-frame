<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Raspberry Pi Photo Frame</title>
  <link rel="stylesheet" href="fonts/inter.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="pixi-canvas-container"></div>

  <div class="overlay-container">
    <div id="clock-container">
      <div id="time"></div>
      <div id="date"></div>
    </div>
    <div id="weather-container">
      <div id="weather-icon"></div>
      <div id="weather-temp"></div>
      <div id="weather-desc"></div>
    </div>
    <div id="photo-info-container">
      <div id="album-name"></div>
      <div id="photo-date"></div>
    </div>
    <div id="debug-status" style="position: absolute; top: 10px; left: 10px; color: white; font-size: 12px; background: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px;"></div>
  </div>

  <script src="/lib/pixi.js/dist/pixi.min.js"></script>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const timeEl = document.getElementById('time');
      const dateEl = document.getElementById('date');
      const weatherContainer = document.getElementById('weather-container');
      const weatherIconEl = document.getElementById('weather-icon');
      const weatherTempEl = document.getElementById('weather-temp');
      const weatherDescEl = document.getElementById('weather-desc');
      const photoInfoContainer = document.getElementById('photo-info-container');
      const albumNameEl = document.getElementById('album-name');
      const photoDateEl = document.getElementById('photo-date');
      const debugStatusEl = document.getElementById('debug-status');

      function updateDebugStatus(message) {
        console.log('DEBUG:', message);
        debugStatusEl.textContent = message;
      }

      let config = {};
      let images = [];
      let currentImageIndex = 0;
      let progressPie = null;
      let progressTicker = null;
      let imageContainer = null;
      let overlayContainer = null;

      let app; // Declare here so it's accessible everywhere

      async function init() {
        // Initialize PixiJS app by passing options directly to the constructor.
        app = new PIXI.Application({
          background: '#000000',
          resizeTo: window,
          autoDensity: true,
          resolution: window.devicePixelRatio || 1,
        });
        document.getElementById('pixi-canvas-container').appendChild(app.view);

        // Create containers for proper layering
        imageContainer = new PIXI.Container();
        overlayContainer = new PIXI.Container();
        app.stage.addChild(imageContainer);
        app.stage.addChild(overlayContainer);

        // Fetch config and initial data
        config = await (await fetch('/api/config')).json();
        images = await (await fetch('/api/images')).json();

        if (images.length === 0) {
          showError("No images found. Add photos to the 'photos' directory.");
          return;
        }

        // Setup overlays
        setupClock();
        setupPhotoInfo();
        if (config.clock.enabled) {
          updateClock(); // Initial call
          setInterval(updateClock, 1000);
        }

        if (config.weather.enabled) {
          updateWeather();
          setInterval(updateWeather, 15 * 60 * 1000); // Update every 15 mins
        }

        // Start the slideshow
        startSlideshow();
      }

      function setupClock() {
        const clockContainer = document.getElementById('clock-container');
        clockContainer.style.display = config.clock.enabled ? 'block' : 'none';
        dateEl.style.display = config.clock.showDate ? 'block' : 'none';
      }

      function setupPhotoInfo() {
        photoInfoContainer.style.display = config.albums.enabled ? 'block' : 'none';
      }

      function updatePhotoInfo(imageInfo) {
        if (!config.albums.enabled) return;
        
        if (config.albums.showAlbumName && imageInfo.album) {
          albumNameEl.textContent = imageInfo.album;
          albumNameEl.style.display = 'block';
        } else {
          albumNameEl.style.display = 'none';
        }
        
        if (config.albums.showPhotoDate && imageInfo.dateTime) {
          const date = new Date(imageInfo.dateTime.replace(/:(\d{2})$/, ''));
          photoDateEl.textContent = date.toLocaleDateString([], { month: 'long', day: 'numeric', year: 'numeric' });
          photoDateEl.style.display = 'block';
        } else {
          photoDateEl.style.display = 'none';
        }
      }

      function updateClock() {
        const now = new Date();
        // Use native JS date formatting. This is simpler and removes the date-fns dependency.
        // The format options from config.json will be ignored in favor of these sensible defaults.
        timeEl.textContent = now.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
        if (config.clock.showDate) {
          dateEl.textContent = now.toLocaleDateString([], { weekday: 'long', month: 'long', day: 'numeric' });
        }
      }

      async function updateWeather() {
        try {
          const weather = await (await fetch('/api/weather')).json();
          if (weather && !weather.error) {
            weatherContainer.style.display = 'flex';
            weatherTempEl.textContent = `${weather.temp}Â°`;
            weatherDescEl.textContent = weather.description;
            // OpenWeatherMap icons can be mapped to a local set or SVGs
            weatherIconEl.innerHTML = `<img src="https://openweathermap.org/img/wn/${weather.icon}@2x.png" alt="Weather icon">`;
          } else {
            weatherContainer.style.display = 'none';
          }
        } catch (e) {
          weatherContainer.style.display = 'none';
        }
      }

      function createProgressPie() {
        const graphics = new PIXI.Graphics();
        graphics.x = window.innerWidth - 40;
        graphics.y = 40;
        graphics.alpha = 0.6;
        overlayContainer.addChild(graphics);
        return graphics;
      }

      function updateProgressPie(progress) {
        if (!progressPie) return;
        
        progressPie.clear();
        
        // Background circle
        progressPie.beginFill(0x666666, 0.3);
        progressPie.drawCircle(0, 0, 15);
        progressPie.endFill();
        
        // Progress arc
        if (progress > 0) {
          progressPie.beginFill(0xffffff, 0.7);
          progressPie.moveTo(0, 0);
          progressPie.lineTo(0, -15);
          progressPie.arc(0, 0, 15, -Math.PI / 2, -Math.PI / 2 + (progress * 2 * Math.PI));
          progressPie.lineTo(0, 0);
          progressPie.endFill();
        }
      }

      function startSlideshow() {
        let currentSprite = null;
        let nextSprite = null;
        
        // Create progress pie
        progressPie = createProgressPie();

        const displayImage = async () => {
          if (images.length === 0) {
            updateDebugStatus('No images available');
            return;
          }

          const imageInfo = images[currentImageIndex];
          updateDebugStatus(`Loading image ${currentImageIndex + 1}/${images.length}: ${imageInfo.url}`);
          
          try {
            const texture = await PIXI.Assets.load(imageInfo.url);
            updateDebugStatus(`Loaded image ${currentImageIndex + 1}, starting transition`);

          // Update photo info
          updatePhotoInfo(imageInfo);

          // Create the next sprite and set it to be invisible
          nextSprite = new PIXI.Sprite(texture);
          resizeSprite(nextSprite);
          nextSprite.alpha = 0;
          imageContainer.addChild(nextSprite);

          // Animate transition using the application's ticker for better lifecycle management.
          const ticker = app.ticker;
          let elapsed = 0;

          // This transition function is now parameter-less.
          // We will get the delta time directly from the ticker object itself.
          // This is a more robust pattern that avoids confusion with callback signatures between PixiJS versions.
          const transition = () => {
            elapsed += ticker.deltaMS; // Use the deltaMS from the ticker instance.
            const progress = Math.min(elapsed / config.transitionTime, 1);

            nextSprite.alpha = progress;
            if (currentSprite) {
              currentSprite.alpha = 1 - progress;
            }

            if (progress >= 1) {
              ticker.remove(transition);
              // Clean up old sprite and texture
              if (currentSprite) {
                imageContainer.removeChild(currentSprite);
                currentSprite.destroy();
              }
              currentSprite = nextSprite;
              nextSprite = null;

              updateDebugStatus(`Image ${currentImageIndex + 1} displayed, preloading next`);

              // Preload next image, then start timer
              const nextImageIndex = (currentImageIndex + 1) % images.length;
              if (images[nextImageIndex]) {
                PIXI.Assets.load(images[nextImageIndex].url).then(() => {
                  updateDebugStatus(`Next image preloaded, starting timer`);
                  
                  // Start progress pie animation only after next image is loaded
                  let imageElapsed = 0;
                  const updateProgress = () => {
                    imageElapsed += ticker.deltaMS;
                    const progress = Math.min(imageElapsed / config.imageDisplayTime, 1);
                    updateProgressPie(progress);
                    
                    if (progress >= 1) {
                      updateDebugStatus(`Timer complete, loading next image`);
                      ticker.remove(updateProgress);
                      displayImage();
                    }
                  };
                  
                  progressTicker = updateProgress;
                  ticker.add(updateProgress);
                }).catch(error => {
                  updateDebugStatus(`Preload failed: ${error.message}`);
                  // Start timer anyway if preload fails
                  setTimeout(displayImage, config.imageDisplayTime);
                });
              } else {
                // No next image, start timer anyway
                setTimeout(displayImage, config.imageDisplayTime);
              }
            }
          };
          ticker.add(transition);

          } catch (error) {
            updateDebugStatus(`Error loading image: ${error.message}`);
            console.error('Image load error:', error);
            // Skip to next image on error
            currentImageIndex = (currentImageIndex + 1) % images.length;
            setTimeout(displayImage, 1000);
            return;
          }

          // Move to the next image, looping back to the start
          currentImageIndex = (currentImageIndex + 1) % images.length;
        };

        displayImage();
      }

      // This function scales the image to fill the screen while maintaining aspect ratio
      function resizeSprite(sprite) {
        const screenWidth = app.screen.width;
        const screenHeight = app.screen.height;
        const textureWidth = sprite.texture.width;
        const textureHeight = sprite.texture.height;

        const screenRatio = screenWidth / screenHeight;
        const imageRatio = textureWidth / textureHeight;

        if (screenRatio > imageRatio) {
          sprite.width = screenWidth;
          sprite.height = screenWidth / imageRatio;
        } else {
          sprite.height = screenHeight;
          sprite.width = screenHeight * imageRatio;
        }

        sprite.anchor.set(0.5);
        sprite.x = screenWidth / 2;
        sprite.y = screenHeight / 2;
      }

      function showError(message) {
        const errorEl = document.createElement('div');
        errorEl.className = 'error-message';
        errorEl.textContent = message;
        document.body.appendChild(errorEl);
      }

      window.addEventListener('resize', () => {
        // app might not be initialized on first load resize event
        if (app && app.renderer) {
          app.renderer.resize(window.innerWidth, window.innerHeight);
          // Reposition progress pie
          if (progressPie) {
            progressPie.x = window.innerWidth - 40;
            progressPie.y = 40;
          }
        }
      });

      init();
    });
  </script>
</body>

</html>
